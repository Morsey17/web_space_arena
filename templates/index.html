<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Спайс Баталия</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #gameContainer {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            position: relative;
        }
        #bgCanvas {
            border: 2px solid #444;
            background: #000020;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
        }
        #gameCanvas {
            border: 2px solid #444;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
        }
        .canvas-wrapper {
            position: relative;
            width: 1000px;
            height: 600px;
        }
    </style>
</head>
<body>
    <h1>Спайс Баталия (WebGL версия)</h1>

    <div id="gameContainer">
        <div class="canvas-wrapper">
            <canvas id="bgCanvas" width="1000" height="600"></canvas>
            <canvas id="gameCanvas" width="1000" height="600"></canvas>
        </div>
    </div>

    <div id="controls">
        <h3>СТАТУС:</h3>
        <div id="status">Загрузка WebGL...</div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="{{ url_for('static', filename='js/webgl-renderer.js') }}"></script>
    <script>
        const STATIC_PATH = "{{ url_for('static', filename='') }}";
        // Глобальные переменные
        const canvas = document.getElementById('gameCanvas');
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        
        let gameState = null;
        let connect = false;
        let myTeam = 0;
        let myShipId = null;
        window.sid = null; // делаем sid глобальным для доступа из WebGLRenderer
        let myShip = null;
        
        let webglRenderer = null;

        // Подключение к серверу
        const socket = io();

        // Инициализация WebGL
        async function initWebGL() {
            try {
                webglRenderer = new WebGLRenderer(canvas);
                
                // Передайте путь к текстурам
                await webglRenderer.init(STATIC_PATH + 'textures/');
                
                statusDiv.textContent = 'WebGL инициализирован!';
                return true;
            } catch (error) {
                console.error('WebGL failed:', error);
                return false;
            }
        }

        // Сокет события
        socket.on('connect', (data) => {
            if (data != null) {
                window.sid = data.sid;
            }
            console.log('Connected with SID:', window.sid);
            statusDiv.textContent = 'Подключено! Выберите команду (A - красные, D - синие, ПРОБЕЛ - присоединиться).';
        });

        socket.on('disconnect', () => {
            statusDiv.textContent = 'Отключение от сервера.';
        });

        socket.on('joined', (data) => {
            myShipId = data.ship_id;
            statusDiv.textContent = `Присоединились к команде ${data.team}! ID корабля: ${myShipId}`;
        });

        socket.on('game_state', (state) => {
            gameState = state;
            drawGame();
        });

        // Обработка клавиш
        document.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();
            if (['A', 'D', 'O', 'P', ' '].includes(key)) {
                if (key === ' ') {
                    socket.emit('player_keydown', { key: 'SPACE' });
                } else {
                    socket.emit('player_keydown', { key });
                }

                if (!connect) {
                    if (key === 'A') myTeam = 0;
                    if (key === 'D') myTeam = 1;
                    if (key === ' ') {
                        connect = true;
                        socket.emit('join_team', { 'team': myTeam });
                    }
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toUpperCase();
            if (['A', 'D', 'O', 'P', ' '].includes(key)) {
                if (key === ' ') {
                    socket.emit('player_keyup', { key: 'SPACE' });
                } else {
                    socket.emit('player_keyup', { key });
                }
                e.preventDefault();
            }
        });

        // Функции для отрисовки на Canvas 2D (фон, интерфейс, радар)
        function drawBackground() {
            // Очищаем фон
            bgCtx.fillStyle = '#050505';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            // Рисуем сетку
            if (webglRenderer && gameState) {
                const cameraX = webglRenderer.cameraX;
                const cameraY = webglRenderer.cameraY;
                
                bgCtx.strokeStyle = 'rgb(50, 125, 50)';
                bgCtx.lineWidth = 2;
                const gridSize = 50;

                for (let x = 0; x < bgCanvas.width; x += gridSize) {
                    bgCtx.beginPath();
                    bgCtx.moveTo(x - cameraX % gridSize + gridSize, 0);
                    bgCtx.lineTo(x - cameraX % gridSize + gridSize, bgCanvas.height);
                    bgCtx.stroke();
                }

                for (let y = 0; y < bgCanvas.height; y += gridSize) {
                    bgCtx.beginPath();
                    bgCtx.moveTo(0, y - cameraY % gridSize + gridSize);
                    bgCtx.lineTo(bgCanvas.width, y - cameraY % gridSize + gridSize);
                    bgCtx.stroke();
                }

                // Рисуем радар и интерфейс (старый код)
                drawRadarAndUI();
            }
        }

        function drawRadarAndUI() {
            if (!gameState || !myShip) return;

            // Рисуем радар
            const radius_radar = 280;
            bgCtx.beginPath();
            bgCtx.strokeStyle = 'rgb(50, 125, 50)';
            bgCtx.arc(300, 300, radius_radar, 0, 2 * Math.PI);
            bgCtx.lineWidth = 1;
            bgCtx.stroke();

            // Рисуем объекты на радаре
            for (const obj of gameState.met) {
                drawRadar(normValue(webglRenderer.cameraX - obj.x), normValue(webglRenderer.cameraY - obj.y), "met", radius_radar);
            }

            for (let team_i = 0; team_i < 2; team_i++) {
                for (const obj of gameState.drone[team_i]) {
                    drawRadar(normValue(webglRenderer.cameraX - obj.x), normValue(webglRenderer.cameraY - obj.y), "drone", radius_radar, team_i);
                }

                for (const obj of gameState.ship[team_i]) {
                    drawRadar(normValue(webglRenderer.cameraX - obj.x), normValue(webglRenderer.cameraY - obj.y), "ship", radius_radar, team_i);
                }

                for (const obj of gameState.titan[team_i]) {
                    drawRadar(normValue(webglRenderer.cameraX - obj.x), normValue(webglRenderer.cameraY - obj.y), "titan", radius_radar, team_i);
                }
            }
            
            // Рисуем правую панель
            bgCtx.fillStyle = '#000000';
            bgCtx.fillRect(600, 0, 400, 600);

            /*

            // Интерфейс игрока
            if (myShip) {
                const enemyTeam = myTeam === 0 ? 1 : 0;
                
                bgCtx.fillStyle = gameState.team[myTeam].color;
                bgCtx.font = "30px serif";
                bgCtx.fillText("ТВОИ ХЭПАСЫ", 680, 40);
                
                // Полоска здоровья
                bgCtx.fillStyle = 'white';
                bgCtx.fillRect(640, 70, 320, 50);
                bgCtx.fillStyle = 'black';
                bgCtx.fillRect(644, 74, 312, 42);
                bgCtx.fillStyle = gameState.team[myTeam].color;
                bgCtx.fillRect(800 - 150 * myShip.health, 80, 300 * myShip.health, 30);

                if (myShip.admin) {
                    bgCtx.fillText("Я ГЕЙ", 680, 400);
                }
            }

            // Полоски здоровья титанов
            for (let i = 0; i < 2; i++) {
                const obj = gameState.titan[i][0];
                const y = 180 + i * 120;
                bgCtx.fillStyle = gameState.team[i].color;
                bgCtx.font = "30px serif";
                bgCtx.fillText("ТИТАН", 715, y - 20);
                bgCtx.fillStyle = 'white';
                bgCtx.fillRect(640, y, 320, 50);
                bgCtx.fillStyle = 'black';
                bgCtx.fillRect(644, y + 4, 312, 42);
                if (obj.health > 0) {
                    bgCtx.fillStyle = gameState.team[i].color;
                    bgCtx.fillRect(800 - 150 * obj.health, y + 10, 300 * obj.health, 30);
                }
            }

            // Выбор команды
            if (!connect) {
                bgCtx.fillStyle = 'white';
                bgCtx.fillRect(90 + myTeam * 250, 215, 170, 170);
                bgCtx.fillStyle = gameState.team[0].color;
                bgCtx.fillRect(100, 225, 150, 150);
                bgCtx.fillStyle = gameState.team[1].color;
                bgCtx.fillRect(350, 225, 150, 150);
            }*/
        }

        // Вспомогательные функции
        function normValue(value, size = 4000) {
            value = value % size;
            if (value < -size / 2) value += size;
            else if (value > size / 2) value -= size;
            return value;
        }

        function hexToRgba(hex, alpha) {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function drawRadar(x, y, tip, radius_radar, enemyTeam = 0) {
            const pif = Math.sqrt(x * x + y * y);
            x /= pif;
            y /= pif;
            let alpha = 0.5;
            let text = "T";
            let radius = 12;
            
            if (tip === "ship") {
                text = "S";
                radius = 9;
            } else if (tip === "drone") {
                text = "D";
                radius = 6;
            } else if (tip === "met") {
                text = "M";
                radius = 10;
            }
            
            if (pif < radius_radar + 5) alpha = 0.0;
            else if (pif < radius_radar * 5) alpha = (1 - (pif - radius_radar) / (radius_radar * 4)) * 0.5 + 0.5;
            
            let color;
            if (text !== "M")
                color = hexToRgba(gameState.team[enemyTeam].color, alpha);
            else
                color = hexToRgba('#ffff00', alpha);
            
            bgCtx.beginPath();
            bgCtx.fillStyle = color;
            bgCtx.arc(300 - x * radius_radar, 300 - y * radius_radar, radius, 0, 2 * Math.PI);
            bgCtx.lineWidth = 3;
            bgCtx.fill();
            bgCtx.font = "13px arial bold";
            bgCtx.fillStyle = 'black';
            bgCtx.fillText(text, 300 - x * radius_radar - 4, 300 - y * radius_radar + 3);
        }

        // Основная функция отрисовки
        function drawGame() {
            if (!gameState) return;
        
            // Находим наш корабль
            myShip = null;
            for (let team_i in gameState.ship) {
                for (const ship of gameState.ship[team_i]) {
                    if (window.sid === ship.sid) {
                        myShip = ship;
                        myTeam = parseInt(team_i);
                        break;
                    }
                }
                if (myShip) break;
            }
        
            // Рисуем фон на Canvas 2D
            drawBackground();
        
            // Рисуем игровые объекты через WebGL, только если готов
            if (webglRenderer && webglRenderer.isReady) {
                webglRenderer.renderGameState(gameState);
            } else {
                console.log('⏳ WebGL еще не готов, используем Canvas для объектов...');
                // Можете добавить Canvas fallback здесь
            }
        }

        // Инициализация
        async function init() {
            const webglSuccess = await initWebGL();
            if (!webglSuccess) {
                statusDiv.textContent = 'Ошибка инициализации WebGL. Используется Canvas.';
                return;
            }
            
            // Ждем немного, чтобы убедиться что WebGL готов
            await new Promise(resolve => setTimeout(resolve, 100));
            
            statusDiv.textContent = 'WebGL готов! Ожидание подключения к серверу...';
        }

        // Старт
        window.addEventListener('load', init);
    </script>
</body>
</html>